--- ZFSPlugin.pm.orig	2025-05-09 20:27:23.109483798 -0600
+++ ZFSPlugin.pm	2025-05-13 12:53:01.890901494 -0600
@@ -10,13 +10,13 @@
 
 use base qw(PVE::Storage::ZFSPoolPlugin);
 use PVE::Storage::LunCmd::Comstar;
+use PVE::Storage::LunCmd::TrueNAS;
 use PVE::Storage::LunCmd::Istgt;
 use PVE::Storage::LunCmd::Iet;
 use PVE::Storage::LunCmd::LIO;
 
-
-my @ssh_opts = ('-o', 'BatchMode=yes');
-my @ssh_cmd = ('/usr/bin/ssh', @ssh_opts);
+my @ssh_opts    = ( '-o',           'BatchMode=yes' );
+my @ssh_cmd     = ( '/usr/bin/ssh', @ssh_opts );
 my $id_rsa_path = '/etc/pve/priv/zfs';
 
 my $lun_cmds = {
@@ -26,86 +26,103 @@
     modify_lu   => 1,
     add_view    => 1,
     list_view   => 1,
+    list_extent => 1,
     list_lu     => 1,
 };
 
 my $zfs_unknown_scsi_provider = sub {
     my ($provider) = @_;
 
-    die "$provider: unknown iscsi provider. Available [comstar, istgt, iet, LIO]";
+    die "$provider: unknown iscsi provider. Available [comstar, truenas, istgt, iet, LIO]";
 };
 
 my $zfs_get_base = sub {
     my ($scfg) = @_;
 
-    if ($scfg->{iscsiprovider} eq 'comstar') {
+    if ( $scfg->{iscsiprovider} eq 'comstar' ) {
         return PVE::Storage::LunCmd::Comstar::get_base;
-    } elsif ($scfg->{iscsiprovider} eq 'istgt') {
+    }
+    elsif ( $scfg->{iscsiprovider} eq 'truenas' ) {
+        return PVE::Storage::LunCmd::TrueNAS::get_base;
+    }
+    elsif ( $scfg->{iscsiprovider} eq 'istgt' ) {
         return PVE::Storage::LunCmd::Istgt::get_base;
-    } elsif ($scfg->{iscsiprovider} eq 'iet') {
+    }
+    elsif ( $scfg->{iscsiprovider} eq 'iet' ) {
         return PVE::Storage::LunCmd::Iet::get_base;
-    } elsif ($scfg->{iscsiprovider} eq 'LIO') {
+    }
+    elsif ( $scfg->{iscsiprovider} eq 'LIO' ) {
         return PVE::Storage::LunCmd::LIO::get_base;
-    } else {
-        $zfs_unknown_scsi_provider->($scfg->{iscsiprovider});
+    }
+    else {
+        $zfs_unknown_scsi_provider->( $scfg->{iscsiprovider} );
     }
 };
 
 sub zfs_request {
-    my ($class, $scfg, $timeout, $method, @params) = @_;
+    my ( $class, $scfg, $timeout, $method, @params ) = @_;
 
-    $timeout = PVE::RPCEnvironment->is_worker() ? 60*60 : 10
-	if !$timeout;
+    $timeout = PVE::RPCEnvironment->is_worker() ? 60 * 60 : 10
+      if !$timeout;
 
     my $msg = '';
 
-    if ($lun_cmds->{$method}) {
-        if ($scfg->{iscsiprovider} eq 'comstar') {
-            $msg = PVE::Storage::LunCmd::Comstar::run_lun_command($scfg, $timeout, $method, @params);
-        } elsif ($scfg->{iscsiprovider} eq 'istgt') {
-            $msg = PVE::Storage::LunCmd::Istgt::run_lun_command($scfg, $timeout, $method, @params);
-        } elsif ($scfg->{iscsiprovider} eq 'iet') {
-            $msg = PVE::Storage::LunCmd::Iet::run_lun_command($scfg, $timeout, $method, @params);
-        } elsif ($scfg->{iscsiprovider} eq 'LIO') {
-            $msg = PVE::Storage::LunCmd::LIO::run_lun_command($scfg, $timeout, $method, @params);
-        } else {
-            $zfs_unknown_scsi_provider->($scfg->{iscsiprovider});
-        }
-    } else {
-
-	my $target = 'root@' . $scfg->{portal};
-
-	my $cmd = [@ssh_cmd, '-i', "$id_rsa_path/$scfg->{portal}_id_rsa", $target];
-
-        if ($method eq 'zpool_list') {
-	    push @$cmd, 'zpool', 'list';
-	} else {
-	    push @$cmd, 'zfs', $method;
-        }
-
-	push @$cmd, @params;
-
-	my $output = sub {
-	    my $line = shift;
-	    $msg .= "$line\n";
+    if ( $lun_cmds->{$method} ) {
+        if ( $scfg->{iscsiprovider} eq 'comstar' ) {
+            $msg = PVE::Storage::LunCmd::Comstar::run_lun_command( $scfg, $timeout, $method, @params );
+        }
+        elsif ( $scfg->{iscsiprovider} eq 'truenas' ) {
+            $msg = PVE::Storage::LunCmd::TrueNAS::run_lun_command( $scfg, $timeout, $method, @params );
+        }
+        elsif ( $scfg->{iscsiprovider} eq 'istgt' ) {
+            $msg = PVE::Storage::LunCmd::Istgt::run_lun_command( $scfg, $timeout, $method, @params );
+        }
+        elsif ( $scfg->{iscsiprovider} eq 'iet' ) {
+            $msg = PVE::Storage::LunCmd::Iet::run_lun_command( $scfg, $timeout, $method, @params );
+        }
+        elsif ( $scfg->{iscsiprovider} eq 'LIO' ) {
+            $msg = PVE::Storage::LunCmd::LIO::run_lun_command( $scfg, $timeout, $method, @params );
+        }
+        else {
+            $zfs_unknown_scsi_provider->( $scfg->{iscsiprovider} );
+        }
+    }
+    else {
+
+        my $target = 'root@' . $scfg->{portal};
+
+        my $cmd = [ @ssh_cmd, '-i', "$id_rsa_path/$scfg->{portal}_id_rsa", $target ];
+
+        if ( $method eq 'zpool_list' ) {
+            push @$cmd, 'zpool', 'list';
+        }
+        else {
+            push @$cmd, 'zfs', $method;
+        }
+
+        push @$cmd, @params;
+
+        my $output = sub {
+            my $line = shift;
+            $msg .= "$line\n";
         };
 
-        run_command($cmd, outfunc => $output, timeout => $timeout);
+        run_command( $cmd, outfunc => $output, timeout => $timeout );
     }
 
     return $msg;
 }
 
 sub zfs_get_lu_name {
-    my ($class, $scfg, $zvol) = @_;
+    my ( $class, $scfg, $zvol ) = @_;
 
     my $base = $zfs_get_base->($scfg);
 
-    $zvol = ($class->parse_volname($zvol))[1];
+    $zvol = ( $class->parse_volname($zvol) )[1];
 
-    my $object = ($zvol =~ /^.+\/.+/) ? "$base/$zvol" : "$base/$scfg->{pool}/$zvol";
+    my $object = ( $zvol =~ /^.+\/.+/ ) ? "$base/$zvol" : "$base/$scfg->{pool}/$zvol";
 
-    my $lu_name = $class->zfs_request($scfg, undef, 'list_lu', $object);
+    my $lu_name = $class->zfs_request( $scfg, undef, 'list_lu', $object );
 
     return $lu_name if $lu_name;
 
@@ -113,59 +130,68 @@
 }
 
 sub zfs_add_lun_mapping_entry {
-    my ($class, $scfg, $zvol, $guid) = @_;
+    my ( $class, $scfg, $zvol, $guid ) = @_;
 
-    if (!defined($guid)) {
-	$guid = $class->zfs_get_lu_name($scfg, $zvol);
+    if ( !defined($guid) ) {
+        $guid = $class->zfs_get_lu_name( $scfg, $zvol );
     }
 
-    $class->zfs_request($scfg, undef, 'add_view', $guid);
+    $class->zfs_request( $scfg, undef, 'add_view', $guid );
 }
 
 sub zfs_delete_lu {
-    my ($class, $scfg, $zvol) = @_;
+    my ( $class, $scfg, $zvol ) = @_;
 
-    my $guid = $class->zfs_get_lu_name($scfg, $zvol);
+    my $guid = $class->zfs_get_lu_name( $scfg, $zvol );
 
-    $class->zfs_request($scfg, undef, 'delete_lu', $guid);
+    $class->zfs_request( $scfg, undef, 'delete_lu', $guid );
 }
 
 sub zfs_create_lu {
-    my ($class, $scfg, $zvol) = @_;
+    my ( $class, $scfg, $zvol ) = @_;
 
     my $base = $zfs_get_base->($scfg);
-    my $guid = $class->zfs_request($scfg, undef, 'create_lu', "$base/$scfg->{pool}/$zvol");
+    my $guid = $class->zfs_request( $scfg, undef, 'create_lu', "$base/$scfg->{pool}/$zvol" );
 
     return $guid;
 }
 
 sub zfs_import_lu {
-    my ($class, $scfg, $zvol) = @_;
+    my ( $class, $scfg, $zvol ) = @_;
 
     my $base = $zfs_get_base->($scfg);
-    $class->zfs_request($scfg, undef, 'import_lu', "$base/$scfg->{pool}/$zvol");
+    $class->zfs_request( $scfg, undef, 'import_lu', "$base/$scfg->{pool}/$zvol" );
 }
 
 sub zfs_resize_lu {
-    my ($class, $scfg, $zvol, $size) = @_;
+    my ( $class, $scfg, $zvol, $size ) = @_;
 
-    my $guid = $class->zfs_get_lu_name($scfg, $zvol);
+    my $guid = $class->zfs_get_lu_name( $scfg, $zvol );
 
-    $class->zfs_request($scfg, undef, 'modify_lu', "${size}K", $guid);
+    $class->zfs_request( $scfg, undef, 'modify_lu', "${size}K", $guid );
 }
 
 sub zfs_get_lun_number {
-    my ($class, $scfg, $guid) = @_;
+    my ( $class, $scfg, $guid ) = @_;
 
     die "could not find lun_number for guid $guid" if !$guid;
 
-    if ($class->zfs_request($scfg, undef, 'list_view', $guid) =~ /^(\d+)$/) {
-	return $1;
+    if ( $class->zfs_request( $scfg, undef, 'list_view', $guid ) =~ /^(\d+)$/ ) {
+        return $1;
     }
 
     die "lun_number for guid $guid is not a number";
 }
 
+# Part of the multipath enhancement
+sub zfs_get_wwid_number {
+    my ( $class, $scfg, $guid ) = @_;
+
+    die "could not find lun_number for guid $guid" if !$guid;
+
+    return $class->zfs_request( $scfg, undef, 'list_extent', $guid );
+}
+
 # Configuration
 
 sub type {
@@ -173,86 +199,149 @@
 }
 
 sub plugindata {
-    return {
-	content => [ {images => 1}, { images => 1 }],
-    };
+    return { content => [ { images => 1 }, { images => 1 } ], };
 }
 
 sub properties {
     return {
-	iscsiprovider => {
-	    description => "iscsi provider",
-	    type => 'string',
-	},
-	# this will disable write caching on comstar and istgt.
-	# it is not implemented for iet. iet blockio always operates with
-	# writethrough caching when not in readonly mode
-	nowritecache => {
-	    description => "disable write caching on the target",
-	    type => 'boolean',
-	},
-	comstar_tg => {
-	    description => "target group for comstar views",
-	    type => 'string',
-	},
-	comstar_hg => {
-	    description => "host group for comstar views",
-	    type => 'string',
-	},
-	lio_tpg => {
-	    description => "target portal group for Linux LIO targets",
-	    type => 'string',
-	},
+        iscsiprovider => {
+            description => "iscsi provider",
+            type        => 'string',
+        },
+
+        # This is for TrueNAS iscsi and API intergration
+        # And some enhancements asked by the community
+        truenas_user => {
+            description => "TrueNAS API Username",
+            type        => 'string',
+        },
+        truenas_password => {
+            description => "TrueNAS API Password",
+            type        => 'string',
+        },
+        truenas_use_ssl => {
+            description => "TrueNAS API access via SSL",
+            type        => 'boolean',
+        },
+        truenas_apiv4_host => {
+            description => "TrueNAS API Host",
+            type        => 'string',
+        },
+        truenas_apikey => {
+            description => "TrueNAS API key",
+            type        => 'string',
+        },
+
+        # this will disable write caching on comstar and istgt.
+        # it is not implemented for iet. iet blockio always operates with
+        # writethrough caching when not in readonly mode
+        nowritecache => {
+            description => "disable write caching on the target",
+            type        => 'boolean',
+        },
+        comstar_tg => {
+            description => "target group for comstar views",
+            type        => 'string',
+        },
+        comstar_hg => {
+            description => "host group for comstar views",
+            type        => 'string',
+        },
+        lio_tpg => {
+            description => "target portal group for Linux LIO targets",
+            type        => 'string',
+        },
     };
 }
 
 sub options {
     return {
-	nodes => { optional => 1 },
-	disable => { optional => 1 },
-	portal => { fixed => 1 },
-	target => { fixed => 1 },
-	pool => { fixed => 1 },
-	blocksize => { fixed => 1 },
-	iscsiprovider => { fixed => 1 },
-	nowritecache => { optional => 1 },
-	sparse => { optional => 1 },
-	comstar_hg => { optional => 1 },
-	comstar_tg => { optional => 1 },
-	lio_tpg => { optional => 1 },
-	content => { optional => 1 },
-	bwlimit => { optional => 1 },
+        nodes              => { optional => 1 },
+        disable            => { optional => 1 },
+        portal             => { fixed    => 1 },
+        target             => { fixed    => 0 },
+        pool               => { fixed    => 0 },
+        blocksize          => { fixed    => 1 },
+        iscsiprovider      => { fixed    => 1 },
+        nowritecache       => { optional => 1 },
+        sparse             => { optional => 1 },
+        comstar_hg         => { optional => 1 },
+        comstar_tg         => { optional => 1 },
+        truenas_user       => { optional => 1 },
+        truenas_password   => { optional => 1 },
+        truenas_use_ssl    => { optional => 1 },
+        truenas_apiv4_host => { optional => 1 },
+        truenas_apikey     => { optional => 1 },
+        lio_tpg            => { optional => 1 },
+        content            => { optional => 1 },
+        bwlimit            => { optional => 1 },
     };
 }
 
 # Storage implementation
 
 sub path {
-    my ($class, $scfg, $volname, $storeid, $snapname) = @_;
+    my ( $class, $scfg, $volname, $storeid, $snapname ) = @_;
 
     die "direct access to snapshots not implemented"
-	if defined($snapname);
+      if defined($snapname);
 
-    my ($vtype, $name, $vmid) = $class->parse_volname($volname);
+    my ( $vtype, $name, $vmid ) = $class->parse_volname($volname);
 
     my $target = $scfg->{target};
     my $portal = $scfg->{portal};
 
-    my $guid = $class->zfs_get_lu_name($scfg, $name);
-    my $lun = $class->zfs_get_lun_number($scfg, $guid);
+    my $guid = $class->zfs_get_lu_name( $scfg, $name );
+    my $lun  = $class->zfs_get_lun_number( $scfg, $guid );
 
     my $path = "iscsi://$portal/$target/$lun";
 
-    return ($path, $vmid, $vtype);
+    # Multipath enhancement
+    eval {
+        my $wwid = $class->zfs_get_wwid_number( $scfg, $guid );
+
+        #	syslog(info,"JD: path get_lun_number guid $guid");
+
+        if ( $wwid =~ /^([-\@\w.]+)$/ ) {
+            $wwid = $1;    # $data now untainted
+        }
+        else {
+            die "Bad data in '$wwid'";    # log this somewhere
+        }
+        my $wwid_end = substr $wwid, 16;
+
+        my $mapper = '';
+        sleep 3;
+        run_command("iscsiadm -m session --rescan");
+        sleep 3;
+        my $line = `/usr/sbin/multipath -ll | grep \"$wwid_end\"`;
+        my ($mapper_device) = split( ' ', $line );
+        $mapper_device = "" unless $mapper_device;
+        $mapper .= $mapper_device;
+
+        if ( $mapper =~ /^([-\@\w.]+)$/ ) {
+            $mapper = $1;    # $data now untainted
+        }
+        else {
+            $mapper = '';
+        }
+
+        #	syslog(info,"Multipath mapper found: $mapper\n");
+        if ( $mapper ne "" ) {
+            $path = "/dev/mapper/$mapper";
+            sleep 5;
+        }
+    };
+
+    return ( $path, $vmid, $vtype );
 }
 
 sub create_base {
-    my ($class, $storeid, $scfg, $volname) = @_;
+    my ( $class, $storeid, $scfg, $volname ) = @_;
 
     my $snap = '__base__';
 
-    my ($vtype, $name, $vmid, $basename, $basevmid, $isBase) =
-        $class->parse_volname($volname);
+    my ( $vtype, $name, $vmid, $basename, $basevmid, $isBase ) = $class->parse_volname($volname);
 
     die "create_base not possible with base image\n" if $isBase;
 
@@ -261,64 +350,64 @@
 
     my $newvolname = $basename ? "$basename/$newname" : "$newname";
 
-    $class->zfs_delete_lu($scfg, $name);
-    $class->zfs_request($scfg, undef, 'rename', "$scfg->{pool}/$name", "$scfg->{pool}/$newname");
+    $class->zfs_delete_lu( $scfg, $name );
+    $class->zfs_request( $scfg, undef, 'rename', "$scfg->{pool}/$name", "$scfg->{pool}/$newname" );
 
-    my $guid = $class->zfs_create_lu($scfg, $newname);
-    $class->zfs_add_lun_mapping_entry($scfg, $newname, $guid);
+    my $guid = $class->zfs_create_lu( $scfg, $newname );
+    $class->zfs_add_lun_mapping_entry( $scfg, $newname, $guid );
 
-    my $running  = undef; #fixme : is create_base always offline ?
+    my $running = undef;    #fixme : is create_base always offline ?
 
-    $class->volume_snapshot($scfg, $storeid, $newname, $snap, $running);
+    $class->volume_snapshot( $scfg, $storeid, $newname, $snap, $running );
 
     return $newvolname;
 }
 
 sub clone_image {
-    my ($class, $scfg, $storeid, $volname, $vmid, $snap) = @_;
+    my ( $class, $scfg, $storeid, $volname, $vmid, $snap ) = @_;
 
-    my $name = $class->SUPER::clone_image($scfg, $storeid, $volname, $vmid, $snap);
+    my $name = $class->SUPER::clone_image( $scfg, $storeid, $volname, $vmid, $snap );
 
     # get ZFS dataset name from PVE volname
-    my (undef, $clonedname) = $class->parse_volname($name);
+    my ( undef, $clonedname ) = $class->parse_volname($name);
 
-    my $guid = $class->zfs_create_lu($scfg, $clonedname);
-    $class->zfs_add_lun_mapping_entry($scfg, $clonedname, $guid);
+    my $guid = $class->zfs_create_lu( $scfg, $clonedname );
+    $class->zfs_add_lun_mapping_entry( $scfg, $clonedname, $guid );
 
     return $name;
 }
 
 sub alloc_image {
-    my ($class, $storeid, $scfg, $vmid, $fmt, $name, $size) = @_;
-    
+    my ( $class, $storeid, $scfg, $vmid, $fmt, $name, $size ) = @_;
+
     die "unsupported format '$fmt'" if $fmt ne 'raw';
 
     die "illegal name '$name' - should be 'vm-$vmid-*'\n"
-    if $name && $name !~ m/^vm-$vmid-/;
+      if $name && $name !~ m/^vm-$vmid-/;
 
     my $volname = $name;
 
-    $volname = $class->find_free_diskname($storeid, $scfg, $vmid, $fmt) if !$volname;
-    
-    $class->zfs_create_zvol($scfg, $volname, $size);
- 
-    my $guid = $class->zfs_create_lu($scfg, $volname);
-    $class->zfs_add_lun_mapping_entry($scfg, $volname, $guid);
+    $volname = $class->find_free_diskname( $storeid, $scfg, $vmid, $fmt ) if !$volname;
+
+    $class->zfs_create_zvol( $scfg, $volname, $size );
+
+    my $guid = $class->zfs_create_lu( $scfg, $volname );
+    $class->zfs_add_lun_mapping_entry( $scfg, $volname, $guid );
 
     return $volname;
 }
 
 sub free_image {
-    my ($class, $storeid, $scfg, $volname, $isBase) = @_;
+    my ( $class, $storeid, $scfg, $volname, $isBase ) = @_;
 
-    my ($vtype, $name, $vmid) = $class->parse_volname($volname);
+    my ( $vtype, $name, $vmid ) = $class->parse_volname($volname);
 
-    $class->zfs_delete_lu($scfg, $name);
+    $class->zfs_delete_lu( $scfg, $name );
 
-    eval { $class->zfs_delete_zvol($scfg, $name); };
-    if (my $err = $@) {
-        my $guid = $class->zfs_create_lu($scfg, $name);
-        $class->zfs_add_lun_mapping_entry($scfg, $name, $guid);
+    eval { $class->zfs_delete_zvol( $scfg, $name ); };
+    if ( my $err = $@ ) {
+        my $guid = $class->zfs_create_lu( $scfg, $name );
+        $class->zfs_add_lun_mapping_entry( $scfg, $name, $guid );
         die $err;
     }
 
@@ -326,64 +415,64 @@
 }
 
 sub volume_resize {
-    my ($class, $scfg, $storeid, $volname, $size, $running) = @_;
+    my ( $class, $scfg, $storeid, $volname, $size, $running ) = @_;
 
-    $volname = ($class->parse_volname($volname))[1];
+    $volname = ( $class->parse_volname($volname) )[1];
 
-    my $new_size = $class->SUPER::volume_resize($scfg, $storeid, $volname, $size, $running);
+    my $new_size = $class->SUPER::volume_resize( $scfg, $storeid, $volname, $size, $running );
 
-    $class->zfs_resize_lu($scfg, $volname, $new_size);
+    $class->zfs_resize_lu( $scfg, $volname, $new_size );
 
     return $new_size;
 }
 
 sub volume_snapshot_delete {
-    my ($class, $scfg, $storeid, $volname, $snap, $running) = @_;
+    my ( $class, $scfg, $storeid, $volname, $snap, $running ) = @_;
 
-    $volname = ($class->parse_volname($volname))[1];
+    $volname = ( $class->parse_volname($volname) )[1];
 
-    $class->zfs_request($scfg, undef, 'destroy', "$scfg->{pool}/$volname\@$snap");
+    $class->zfs_request( $scfg, undef, 'destroy', "$scfg->{pool}/$volname\@$snap" );
 }
 
 sub volume_snapshot_rollback {
-    my ($class, $scfg, $storeid, $volname, $snap) = @_;
+    my ( $class, $scfg, $storeid, $volname, $snap ) = @_;
 
-    $volname = ($class->parse_volname($volname))[1];
+    $volname = ( $class->parse_volname($volname) )[1];
 
-    $class->zfs_delete_lu($scfg, $volname);
+    $class->zfs_delete_lu( $scfg, $volname );
 
-    $class->zfs_request($scfg, undef, 'rollback', "$scfg->{pool}/$volname\@$snap");
+    $class->zfs_request( $scfg, undef, 'rollback', "$scfg->{pool}/$volname\@$snap" );
 
-    $class->zfs_import_lu($scfg, $volname);
+    $class->zfs_import_lu( $scfg, $volname );
 
-    $class->zfs_add_lun_mapping_entry($scfg, $volname);
+    $class->zfs_add_lun_mapping_entry( $scfg, $volname );
 }
 
 sub storage_can_replicate {
-    my ($class, $scfg, $storeid, $format) = @_;
+    my ( $class, $scfg, $storeid, $format ) = @_;
 
     return 0;
 }
 
 sub volume_has_feature {
-    my ($class, $scfg, $feature, $storeid, $volname, $snapname, $running) = @_;
+    my ( $class, $scfg, $feature, $storeid, $volname, $snapname, $running ) = @_;
 
     my $features = {
-	snapshot => { current => 1, snap => 1},
-	clone => { base => 1},
-	template => { current => 1},
-	copy => { base => 1, current => 1},
+        snapshot => { current => 1, snap => 1 },
+        clone    => { base    => 1 },
+        template => { current => 1 },
+        copy     => { base    => 1, current => 1 },
     };
 
-    my ($vtype, $name, $vmid, $basename, $basevmid, $isBase) =
-	$class->parse_volname($volname);
+    my ( $vtype, $name, $vmid, $basename, $basevmid, $isBase ) = $class->parse_volname($volname);
 
     my $key = undef;
 
     if ($snapname) {
-	$key = 'snap';
-    } else {
-	$key = $isBase ? 'base' : 'current';
+        $key = 'snap';
+    }
+    else {
+        $key = $isBase ? 'base' : 'current';
     }
 
     return 1 if $features->{$feature}->{$key};
@@ -392,19 +481,19 @@
 }
 
 sub activate_storage {
-    my ($class, $storeid, $scfg, $cache) = @_;
+    my ( $class, $storeid, $scfg, $cache ) = @_;
 
     return 1;
 }
 
 sub deactivate_storage {
-    my ($class, $storeid, $scfg, $cache) = @_;
+    my ( $class, $storeid, $scfg, $cache ) = @_;
 
     return 1;
 }
 
 sub activate_volume {
-    my ($class, $storeid, $scfg, $volname, $snapname, $cache) = @_;
+    my ( $class, $storeid, $scfg, $volname, $snapname, $cache ) = @_;
 
     die "unable to activate snapshot from remote zfs storage" if $snapname;
 
@@ -412,7 +501,7 @@
 }
 
 sub deactivate_volume {
-    my ($class, $storeid, $scfg, $volname, $snapname, $cache) = @_;
+    my ( $class, $storeid, $scfg, $volname, $snapname, $cache ) = @_;
 
     die "unable to deactivate snapshot from remote zfs storage" if $snapname;
 
